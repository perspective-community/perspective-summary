{"version":3,"names":["JSONExt","isPrimitive","value","isArray","Array","deepEqual","first","second","a1","a2","length","i","n","deepArrayEqual","key","undefined","firstValue","secondValue","deepObjectEqual","deepCopy","result","deepArrayCopy","subvalue","deepObjectCopy","emptyObject","Object","freeze","emptyArray","isObject","Private","PluginData","constructor","plugin","this","_activated","_promise","_service","id","description","_a","activate","deactivate","_b","provides","_c","autoStart","_d","requires","slice","optional","activated","a","service","s","promise","p","createPluginData","ensureNoCycle","plugins","services","dependencies","visit","token","get","visited","trace","push","some","pop","ReferenceError","join","findDependents","edges","add","reduce","acc","dep","keys","newEdges","filter","edge","oldSize","previousSize","packagesOfInterest","Set","map","poi","forEach","includes","sorted","topologicSort","index","findIndex","candidate","collectStartupPlugins","options","collection","startPlugins","ignorePlugins","delete","from","fallbackRandomValues","buffer","Math","random","Random","getRandomValues","crypto","window","msCrypto","UUID","uuid4","bytes","Uint8Array","lut","toString","uuid4Factory","_types","_values","types","hasData","mime","indexOf","getData","setData","data","clearData","splice","clear","_application","_validatePlugin","_plugins","Map","_services","validatePlugin","console","info","application","v","Error","deferredPlugins","getPluginDescription","hasPlugin","has","isPluginActivated","listPlugins","registerPlugin","TypeError","set","registerPlugins","deregisterPlugin","force","async","required","t","resolveRequiredService","resolveOptionalService","Promise","all","then","apply","catch","error","kind","promises","pluginId","activatePlugin","manifest","downstream","name","reason","resolve","reject","_resolve","_reject","_tokenStructuralPropertyT"],"sources":["../src/json.ts","../src/plugins.ts","../src/random.ts","../src/random.browser.ts","../src/uuid.browser.ts","../src/uuid.ts","../src/mime.ts","../src/promise.ts","../src/token.ts"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n\n/**\n * A type alias for a JSON primitive.\n */\nexport type JSONPrimitive = boolean | number | string | null;\n\n/**\n * A type alias for a JSON value.\n */\nexport type JSONValue = JSONPrimitive | JSONObject | JSONArray;\n\n/**\n * A type definition for a JSON object.\n */\nexport interface JSONObject {\n  [key: string]: JSONValue;\n}\n\n/**\n * A type definition for a JSON array.\n */\nexport interface JSONArray extends Array<JSONValue> {}\n\n/**\n * A type definition for a readonly JSON object.\n */\nexport interface ReadonlyJSONObject {\n  readonly [key: string]: ReadonlyJSONValue;\n}\n\n/**\n * A type definition for a readonly JSON array.\n */\nexport interface ReadonlyJSONArray extends ReadonlyArray<ReadonlyJSONValue> {}\n\n/**\n * A type alias for a readonly JSON value.\n */\nexport type ReadonlyJSONValue =\n  | JSONPrimitive\n  | ReadonlyJSONObject\n  | ReadonlyJSONArray;\n\n/**\n * A type alias for a partial JSON value.\n *\n * Note: Partial here means that JSON object attributes can be `undefined`.\n */\nexport type PartialJSONValue =\n  | JSONPrimitive\n  | PartialJSONObject\n  | PartialJSONArray;\n\n/**\n * A type definition for a partial JSON object.\n *\n * Note: Partial here means that the JSON object attributes can be `undefined`.\n */\nexport interface PartialJSONObject {\n  [key: string]: PartialJSONValue | undefined;\n}\n\n/**\n * A type definition for a partial JSON array.\n *\n * Note: Partial here means that JSON object attributes can be `undefined`.\n */\nexport interface PartialJSONArray extends Array<PartialJSONValue> {}\n\n/**\n * A type definition for a readonly partial JSON object.\n *\n * Note: Partial here means that JSON object attributes can be `undefined`.\n */\nexport interface ReadonlyPartialJSONObject {\n  readonly [key: string]: ReadonlyPartialJSONValue | undefined;\n}\n\n/**\n * A type definition for a readonly partial JSON array.\n *\n * Note: Partial here means that JSON object attributes can be `undefined`.\n */\nexport interface ReadonlyPartialJSONArray\n  extends ReadonlyArray<ReadonlyPartialJSONValue> {}\n\n/**\n * A type alias for a readonly partial JSON value.\n *\n * Note: Partial here means that JSON object attributes can be `undefined`.\n */\nexport type ReadonlyPartialJSONValue =\n  | JSONPrimitive\n  | ReadonlyPartialJSONObject\n  | ReadonlyPartialJSONArray;\n\n/**\n * The namespace for JSON-specific functions.\n */\nexport namespace JSONExt {\n  /**\n   * A shared frozen empty JSONObject\n   */\n  export const emptyObject = Object.freeze({}) as ReadonlyJSONObject;\n\n  /**\n   * A shared frozen empty JSONArray\n   */\n  export const emptyArray = Object.freeze([]) as ReadonlyJSONArray;\n\n  /**\n   * Test whether a JSON value is a primitive.\n   *\n   * @param value - The JSON value of interest.\n   *\n   * @returns `true` if the value is a primitive,`false` otherwise.\n   */\n  export function isPrimitive(\n    value: ReadonlyPartialJSONValue\n  ): value is JSONPrimitive {\n    return (\n      value === null ||\n      typeof value === 'boolean' ||\n      typeof value === 'number' ||\n      typeof value === 'string'\n    );\n  }\n\n  /**\n   * Test whether a JSON value is an array.\n   *\n   * @param value - The JSON value of interest.\n   *\n   * @returns `true` if the value is a an array, `false` otherwise.\n   */\n  export function isArray(value: JSONValue): value is JSONArray;\n  export function isArray(value: ReadonlyJSONValue): value is ReadonlyJSONArray;\n  export function isArray(value: PartialJSONValue): value is PartialJSONArray;\n  export function isArray(\n    value: ReadonlyPartialJSONValue\n  ): value is ReadonlyPartialJSONArray;\n  export function isArray(value: ReadonlyPartialJSONValue): boolean {\n    return Array.isArray(value);\n  }\n\n  /**\n   * Test whether a JSON value is an object.\n   *\n   * @param value - The JSON value of interest.\n   *\n   * @returns `true` if the value is a an object, `false` otherwise.\n   */\n  export function isObject(value: JSONValue): value is JSONObject;\n  export function isObject(\n    value: ReadonlyJSONValue\n  ): value is ReadonlyJSONObject;\n  export function isObject(value: PartialJSONValue): value is PartialJSONObject;\n  export function isObject(\n    value: ReadonlyPartialJSONValue\n  ): value is ReadonlyPartialJSONObject;\n  export function isObject(value: ReadonlyPartialJSONValue): boolean {\n    return !isPrimitive(value) && !isArray(value);\n  }\n\n  /**\n   * Compare two JSON values for deep equality.\n   *\n   * @param first - The first JSON value of interest.\n   *\n   * @param second - The second JSON value of interest.\n   *\n   * @returns `true` if the values are equivalent, `false` otherwise.\n   */\n  export function deepEqual(\n    first: ReadonlyPartialJSONValue,\n    second: ReadonlyPartialJSONValue\n  ): boolean {\n    // Check referential and primitive equality first.\n    if (first === second) {\n      return true;\n    }\n\n    // If one is a primitive, the `===` check ruled out the other.\n    if (isPrimitive(first) || isPrimitive(second)) {\n      return false;\n    }\n\n    // Test whether they are arrays.\n    let a1 = isArray(first);\n    let a2 = isArray(second);\n\n    // Bail if the types are different.\n    if (a1 !== a2) {\n      return false;\n    }\n\n    // If they are both arrays, compare them.\n    if (a1 && a2) {\n      return deepArrayEqual(\n        first as ReadonlyPartialJSONArray,\n        second as ReadonlyPartialJSONArray\n      );\n    }\n\n    // At this point, they must both be objects.\n    return deepObjectEqual(\n      first as ReadonlyPartialJSONObject,\n      second as ReadonlyPartialJSONObject\n    );\n  }\n\n  /**\n   * Create a deep copy of a JSON value.\n   *\n   * @param value - The JSON value to copy.\n   *\n   * @returns A deep copy of the given JSON value.\n   */\n  export function deepCopy<T extends ReadonlyPartialJSONValue>(value: T): T {\n    // Do nothing for primitive values.\n    if (isPrimitive(value)) {\n      return value;\n    }\n\n    // Deep copy an array.\n    if (isArray(value)) {\n      return deepArrayCopy(value);\n    }\n\n    // Deep copy an object.\n    return deepObjectCopy(value);\n  }\n\n  /**\n   * Compare two JSON arrays for deep equality.\n   */\n  function deepArrayEqual(\n    first: ReadonlyPartialJSONArray,\n    second: ReadonlyPartialJSONArray\n  ): boolean {\n    // Check referential equality first.\n    if (first === second) {\n      return true;\n    }\n\n    // Test the arrays for equal length.\n    if (first.length !== second.length) {\n      return false;\n    }\n\n    // Compare the values for equality.\n    for (let i = 0, n = first.length; i < n; ++i) {\n      if (!deepEqual(first[i], second[i])) {\n        return false;\n      }\n    }\n\n    // At this point, the arrays are equal.\n    return true;\n  }\n\n  /**\n   * Compare two JSON objects for deep equality.\n   */\n  function deepObjectEqual(\n    first: ReadonlyPartialJSONObject,\n    second: ReadonlyPartialJSONObject\n  ): boolean {\n    // Check referential equality first.\n    if (first === second) {\n      return true;\n    }\n\n    // Check for the first object's keys in the second object.\n    for (let key in first) {\n      if (first[key] !== undefined && !(key in second)) {\n        return false;\n      }\n    }\n\n    // Check for the second object's keys in the first object.\n    for (let key in second) {\n      if (second[key] !== undefined && !(key in first)) {\n        return false;\n      }\n    }\n\n    // Compare the values for equality.\n    for (let key in first) {\n      // Get the values.\n      let firstValue = first[key];\n      let secondValue = second[key];\n\n      // If both are undefined, ignore the key.\n      if (firstValue === undefined && secondValue === undefined) {\n        continue;\n      }\n\n      // If only one value is undefined, the objects are not equal.\n      if (firstValue === undefined || secondValue === undefined) {\n        return false;\n      }\n\n      // Compare the values.\n      if (!deepEqual(firstValue, secondValue)) {\n        return false;\n      }\n    }\n\n    // At this point, the objects are equal.\n    return true;\n  }\n\n  /**\n   * Create a deep copy of a JSON array.\n   */\n  function deepArrayCopy(value: any): any {\n    let result = new Array<any>(value.length);\n    for (let i = 0, n = value.length; i < n; ++i) {\n      result[i] = deepCopy(value[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Create a deep copy of a JSON object.\n   */\n  function deepObjectCopy(value: any): any {\n    let result: any = {};\n    for (let key in value) {\n      // Ignore undefined values.\n      let subvalue = value[key];\n      if (subvalue === undefined) {\n        continue;\n      }\n      result[key] = deepCopy(subvalue);\n    }\n    return result;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { topologicSort } from '@lumino/algorithm';\n\nimport { Token } from './token';\n\n/**\n * A user-defined application plugin.\n *\n * @typeParam T - The type for the application.\n *\n * @typeParam U - The service type, if the plugin `provides` one.\n *\n * #### Notes\n * Plugins are the foundation for building an extensible application.\n *\n * Plugins consume and provide \"services\", which are nothing more than\n * concrete implementations of interfaces and/or abstract types.\n *\n * Unlike regular imports and exports, which tie the service consumer\n * to a particular implementation of the service, plugins decouple the\n * service producer from the service consumer, allowing an application\n * to be easily customized by third parties in a type-safe fashion.\n */\nexport interface IPlugin<T, U> {\n  /**\n   * The human readable ID of the plugin.\n   *\n   * #### Notes\n   * This must be unique within an application.\n   */\n  id: string;\n\n  /**\n   * Plugin description.\n   *\n   * #### Notes\n   * This can be used to provide user documentation on the feature\n   * brought by a plugin.\n   */\n  description?: string;\n\n  /**\n   * Whether the plugin should be activated on application start or waiting for being\n   * required. If the value is 'defer' then the plugin should be activated only after\n   * the application is started.\n   *\n   * #### Notes\n   * The default is `false`.\n   */\n  autoStart?: boolean | 'defer';\n\n  /**\n   * The types of required services for the plugin, if any.\n   *\n   * #### Notes\n   * These tokens correspond to the services that are required by\n   * the plugin for correct operation.\n   *\n   * When the plugin is activated, a concrete instance of each type\n   * will be passed to the `activate()` function, in the order they\n   * are specified in the `requires` array.\n   */\n  requires?: Token<any>[];\n\n  /**\n   * The types of optional services for the plugin, if any.\n   *\n   * #### Notes\n   * These tokens correspond to the services that can be used by the\n   * plugin if available, but are not necessarily required.\n   *\n   * The optional services will be passed to the `activate()` function\n   * following all required services. If an optional service cannot be\n   * resolved, `null` will be passed in its place.\n   */\n  optional?: Token<any>[];\n\n  /**\n   * The type of service provided by the plugin, if any.\n   *\n   * #### Notes\n   * This token corresponds to the service exported by the plugin.\n   *\n   * When the plugin is activated, the return value of `activate()`\n   * is used as the concrete instance of the type.\n   */\n  provides?: Token<U> | null;\n\n  /**\n   * A function invoked to activate the plugin.\n   *\n   * @param app - The application provided by {@link PluginRegistry.application} .\n   *\n   * @param args - The services specified by the `requires` property.\n   *\n   * @returns The provided service, or a promise to the service.\n   *\n   * #### Notes\n   * This function will be called whenever the plugin is manually\n   * activated, or when another plugin being activated requires\n   * the service it provides.\n   *\n   * This function will not be called unless all of its required\n   * services can be fulfilled.\n   */\n  activate: (app: T, ...args: any[]) => U | Promise<U>;\n\n  /**\n   * A function invoked to deactivate the plugin.\n   *\n   * @param app - The application {@link PluginRegistry.application} .\n   *\n   * @param args - The services specified by the `requires` property.\n   */\n  deactivate?: ((app: T, ...args: any[]) => void | Promise<void>) | null;\n}\n\n/**\n * Plugin registry.\n */\nexport class PluginRegistry<T = any> {\n  constructor(options: PluginRegistry.IOptions = {}) {\n    if (options.validatePlugin) {\n      console.info(\n        'Plugins may be rejected by the custom validation plugin method.'\n      );\n      this._validatePlugin = options.validatePlugin;\n    }\n  }\n\n  /**\n   * The application object.\n   *\n   * It will be provided as first argument to the\n   * plugins activation and deactivation functions.\n   *\n   * It can only be set once.\n   *\n   * By default, it is `null`.\n   */\n  get application(): T {\n    return this._application;\n  }\n  set application(v: T) {\n    if (this._application !== null) {\n      throw Error(\n        'PluginRegistry.application is already set. It cannot be overridden.'\n      );\n    }\n\n    this._application = v;\n  }\n\n  /**\n   * The list of all the deferred plugins.\n   */\n  get deferredPlugins(): string[] {\n    return Array.from(this._plugins)\n      .filter(([id, plugin]) => plugin.autoStart === 'defer')\n      .map(([id, plugin]) => id);\n  }\n\n  /**\n   * Get a plugin description.\n   *\n   * @param id - The ID of the plugin of interest.\n   *\n   * @returns The plugin description.\n   */\n  getPluginDescription(id: string): string {\n    return this._plugins.get(id)?.description ?? '';\n  }\n\n  /**\n   * Test whether a plugin is registered with the application.\n   *\n   * @param id - The ID of the plugin of interest.\n   *\n   * @returns `true` if the plugin is registered, `false` otherwise.\n   */\n  hasPlugin(id: string): boolean {\n    return this._plugins.has(id);\n  }\n\n  /**\n   * Test whether a plugin is activated with the application.\n   *\n   * @param id - The ID of the plugin of interest.\n   *\n   * @returns `true` if the plugin is activated, `false` otherwise.\n   */\n  isPluginActivated(id: string): boolean {\n    return this._plugins.get(id)?.activated ?? false;\n  }\n\n  /**\n   * List the IDs of the plugins registered with the application.\n   *\n   * @returns A new array of the registered plugin IDs.\n   */\n  listPlugins(): string[] {\n    return Array.from(this._plugins.keys());\n  }\n\n  /**\n   * Register a plugin with the application.\n   *\n   * @param plugin - The plugin to register.\n   *\n   * #### Notes\n   * An error will be thrown if a plugin with the same ID is already\n   * registered, or if the plugin has a circular dependency.\n   *\n   * If the plugin provides a service which has already been provided\n   * by another plugin, the new service will override the old service.\n   */\n  registerPlugin(plugin: IPlugin<T, any>): void {\n    // Throw an error if the plugin ID is already registered.\n    if (this._plugins.has(plugin.id)) {\n      throw new TypeError(`Plugin '${plugin.id}' is already registered.`);\n    }\n\n    if (!this._validatePlugin(plugin)) {\n      throw new Error(`Plugin '${plugin.id}' is not valid.`);\n    }\n\n    // Create the normalized plugin data.\n    const data = Private.createPluginData(plugin);\n\n    // Ensure the plugin does not cause a cyclic dependency.\n    Private.ensureNoCycle(data, this._plugins, this._services);\n\n    // Add the service token to the service map.\n    if (data.provides) {\n      this._services.set(data.provides, data.id);\n    }\n\n    // Add the plugin to the plugin map.\n    this._plugins.set(data.id, data);\n  }\n\n  /**\n   * Register multiple plugins with the application.\n   *\n   * @param plugins - The plugins to register.\n   *\n   * #### Notes\n   * This calls `registerPlugin()` for each of the given plugins.\n   */\n  registerPlugins(plugins: IPlugin<T, any>[]): void {\n    for (const plugin of plugins) {\n      this.registerPlugin(plugin);\n    }\n  }\n\n  /**\n   * Deregister a plugin with the application.\n   *\n   * @param id - The ID of the plugin of interest.\n   *\n   * @param force - Whether to deregister the plugin even if it is active.\n   */\n  deregisterPlugin(id: string, force?: boolean): void {\n    const plugin = this._plugins.get(id);\n    if (!plugin) {\n      return;\n    }\n\n    if (plugin.activated && !force) {\n      throw new Error(`Plugin '${id}' is still active.`);\n    }\n\n    this._plugins.delete(id);\n  }\n\n  /**\n   * Activate the plugin with the given ID.\n   *\n   * @param id - The ID of the plugin of interest.\n   *\n   * @returns A promise which resolves when the plugin is activated\n   *   or rejects with an error if it cannot be activated.\n   */\n  async activatePlugin(id: string): Promise<void> {\n    // Reject the promise if the plugin is not registered.\n    const plugin = this._plugins.get(id);\n    if (!plugin) {\n      throw new ReferenceError(`Plugin '${id}' is not registered.`);\n    }\n\n    // Resolve immediately if the plugin is already activated.\n    if (plugin.activated) {\n      return;\n    }\n\n    // Return the pending resolver promise if it exists.\n    if (plugin.promise) {\n      return plugin.promise;\n    }\n\n    // Resolve the required services for the plugin.\n    const required = plugin.requires.map(t => this.resolveRequiredService(t));\n\n    // Resolve the optional services for the plugin.\n    const optional = plugin.optional.map(t => this.resolveOptionalService(t));\n\n    // Setup the resolver promise for the plugin.\n    plugin.promise = Promise.all([...required, ...optional])\n      .then(services =>\n        plugin!.activate.apply(undefined, [this.application, ...services])\n      )\n      .then(service => {\n        plugin!.service = service;\n        plugin!.activated = true;\n        plugin!.promise = null;\n      })\n      .catch(error => {\n        plugin!.promise = null;\n        throw error;\n      });\n\n    // Return the pending resolver promise.\n    return plugin.promise;\n  }\n\n  /**\n   * Activate all the deferred plugins.\n   *\n   * @returns A promise which will resolve when each plugin is activated\n   * or rejects with an error if one cannot be activated.\n   */\n  async activatePlugins(\n    kind: 'startUp' | 'defer',\n    options: PluginRegistry.IStartOptions = {}\n  ): Promise<void> {\n    switch (kind) {\n      case 'defer': {\n        const promises = this.deferredPlugins\n          .filter(pluginId => this._plugins.get(pluginId)!.autoStart)\n          .map(pluginId => {\n            return this.activatePlugin(pluginId);\n          });\n        await Promise.all(promises);\n        break;\n      }\n      case 'startUp': {\n        // Collect the ids of the startup plugins.\n        const startups = Private.collectStartupPlugins(this._plugins, options);\n\n        // Generate the activation promises.\n        const promises = startups.map(async id => {\n          try {\n            return await this.activatePlugin(id);\n          } catch (error) {\n            console.error(`Plugin '${id}' failed to activate.`, error);\n          }\n        });\n        await Promise.all(promises);\n        break;\n      }\n    }\n  }\n\n  /**\n   * Deactivate the plugin and its downstream dependents if and only if the\n   * plugin and its dependents all support `deactivate`.\n   *\n   * @param id - The ID of the plugin of interest.\n   *\n   * @returns A list of IDs of downstream plugins deactivated with this one.\n   */\n  async deactivatePlugin(id: string): Promise<string[]> {\n    // Reject the promise if the plugin is not registered.\n    const plugin = this._plugins.get(id);\n    if (!plugin) {\n      throw new ReferenceError(`Plugin '${id}' is not registered.`);\n    }\n\n    // Bail early if the plugin is not activated.\n    if (!plugin.activated) {\n      return [];\n    }\n\n    // Check that this plugin can deactivate.\n    if (!plugin.deactivate) {\n      throw new TypeError(`Plugin '${id}'#deactivate() method missing`);\n    }\n\n    // Find the optimal deactivation order for plugins downstream of this one.\n    const manifest = Private.findDependents(id, this._plugins, this._services);\n    const downstream = manifest.map(id => this._plugins.get(id)!);\n\n    // Check that all downstream plugins can deactivate.\n    for (const plugin of downstream) {\n      if (!plugin.deactivate) {\n        throw new TypeError(\n          `Plugin ${plugin.id}#deactivate() method missing (depends on ${id})`\n        );\n      }\n    }\n\n    // Deactivate all downstream plugins.\n    for (const plugin of downstream) {\n      const services = [...plugin.requires, ...plugin.optional].map(service => {\n        const id = this._services.get(service);\n        return id ? this._plugins.get(id)!.service : null;\n      });\n\n      // Await deactivation so the next plugins only receive active services.\n      await plugin.deactivate!(this.application, ...services);\n      plugin.service = null;\n      plugin.activated = false;\n    }\n\n    // Remove plugin ID and return manifest of deactivated plugins.\n    manifest.pop();\n    return manifest;\n  }\n\n  /**\n   * Resolve a required service of a given type.\n   *\n   * @param token - The token for the service type of interest.\n   *\n   * @returns A promise which resolves to an instance of the requested\n   *   service, or rejects with an error if it cannot be resolved.\n   *\n   * #### Notes\n   * Services are singletons. The same instance will be returned each\n   * time a given service token is resolved.\n   *\n   * If the plugin which provides the service has not been activated,\n   * resolving the service will automatically activate the plugin.\n   *\n   * User code will not typically call this method directly. Instead,\n   * the required services for the user's plugins will be resolved\n   * automatically when the plugin is activated.\n   */\n  async resolveRequiredService<U>(token: Token<U>): Promise<U> {\n    // Reject the promise if there is no provider for the type.\n    const id = this._services.get(token);\n    if (!id) {\n      throw new TypeError(`No provider for: ${token.name}.`);\n    }\n\n    // Activate the plugin if necessary.\n    const plugin = this._plugins.get(id)!;\n    if (!plugin.activated) {\n      await this.activatePlugin(id);\n    }\n\n    return plugin.service;\n  }\n\n  /**\n   * Resolve an optional service of a given type.\n   *\n   * @param token - The token for the service type of interest.\n   *\n   * @returns A promise which resolves to an instance of the requested\n   *   service, or `null` if it cannot be resolved.\n   *\n   * #### Notes\n   * Services are singletons. The same instance will be returned each\n   * time a given service token is resolved.\n   *\n   * If the plugin which provides the service has not been activated,\n   * resolving the service will automatically activate the plugin.\n   *\n   * User code will not typically call this method directly. Instead,\n   * the optional services for the user's plugins will be resolved\n   * automatically when the plugin is activated.\n   */\n  async resolveOptionalService<U>(token: Token<U>): Promise<U | null> {\n    // Resolve with `null` if there is no provider for the type.\n    const id = this._services.get(token);\n    if (!id) {\n      return null;\n    }\n\n    // Activate the plugin if necessary.\n    const plugin = this._plugins.get(id)!;\n    if (!plugin.activated) {\n      try {\n        await this.activatePlugin(id);\n      } catch (reason) {\n        console.error(reason);\n        return null;\n      }\n    }\n\n    return plugin.service;\n  }\n\n  private _application: any = null;\n  private _validatePlugin: (plugin: IPlugin<any, any>) => boolean = () => true;\n  private _plugins = new Map<string, Private.IPluginData<T>>();\n  private _services = new Map<Token<any>, string>();\n}\n\n/**\n * PluginRegistry namespace\n */\nexport namespace PluginRegistry {\n  /**\n   * PluginRegistry constructor options.\n   */\n  export interface IOptions {\n    /**\n     * Validate that a plugin is allowed to be registered.\n     *\n     * Default is `() => true`.\n     *\n     * @param plugin The plugin to validate\n     * @returns Whether the plugin can be registered or not.\n     *\n     * #### Notes\n     * We recommend you print a console message with the reason\n     * a plugin is invalid.\n     */\n    validatePlugin?: (plugin: IPlugin<any, any>) => boolean;\n  }\n\n  /**\n   * An options object for application startup.\n   */\n  export interface IStartOptions {\n    /**\n     * The plugins to activate on startup.\n     *\n     * #### Notes\n     * These will be *in addition* to any `autoStart` plugins.\n     */\n    startPlugins?: string[];\n\n    /**\n     * The plugins to **not** activate on startup.\n     *\n     * #### Notes\n     * This will override `startPlugins` and any `autoStart` plugins.\n     */\n    ignorePlugins?: string[];\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * An object which holds the full application state for a plugin.\n   */\n  export interface IPluginData<T = any> {\n    /**\n     * The human readable ID of the plugin.\n     */\n    readonly id: string;\n\n    /**\n     * The description of the plugin.\n     */\n    readonly description: string;\n\n    /**\n     * Whether the plugin should be activated on application start or waiting for being\n     * required. If the value is 'defer' then the plugin should be activated only after\n     * the application is started.\n     */\n    readonly autoStart: boolean | 'defer';\n\n    /**\n     * The types of required services for the plugin, or `[]`.\n     */\n    readonly requires: Token<any>[];\n\n    /**\n     * The types of optional services for the the plugin, or `[]`.\n     */\n    readonly optional: Token<any>[];\n\n    /**\n     * The type of service provided by the plugin, or `null`.\n     */\n    readonly provides: Token<any> | null;\n\n    /**\n     * The function which activates the plugin.\n     */\n    readonly activate: (app: T, ...args: any[]) => any;\n\n    /**\n     * The optional function which deactivates the plugin.\n     */\n    readonly deactivate:\n      | ((app: T, ...args: any[]) => void | Promise<void>)\n      | null;\n\n    /**\n     * Whether the plugin has been activated.\n     */\n    activated: boolean;\n\n    /**\n     * The resolved service for the plugin, or `null`.\n     */\n    service: any | null;\n\n    /**\n     * The pending resolver promise, or `null`.\n     */\n    promise: Promise<void> | null;\n  }\n\n  class PluginData<T = any, U = any> implements IPluginData<T> {\n    private _activated = false;\n    private _promise: Promise<void> | null = null;\n    private _service: U | null = null;\n\n    constructor(plugin: IPlugin<T, U>) {\n      this.id = plugin.id;\n      this.description = plugin.description ?? '';\n      this.activate = plugin.activate;\n      this.deactivate = plugin.deactivate ?? null;\n      this.provides = plugin.provides ?? null;\n      this.autoStart = plugin.autoStart ?? false;\n      this.requires = plugin.requires ? plugin.requires.slice() : [];\n      this.optional = plugin.optional ? plugin.optional.slice() : [];\n    }\n\n    /**\n     * The human readable ID of the plugin.\n     */\n    readonly id: string;\n\n    /**\n     * The description of the plugin.\n     */\n    readonly description: string;\n\n    /**\n     * Whether the plugin should be activated on application start or waiting for being\n     * required. If the value is 'defer' then the plugin should be activated only after\n     * the application is started.\n     */\n    readonly autoStart: boolean | 'defer';\n\n    /**\n     * The types of required services for the plugin, or `[]`.\n     */\n    readonly requires: Token<any>[];\n\n    /**\n     * The types of optional services for the the plugin, or `[]`.\n     */\n    readonly optional: Token<any>[];\n\n    /**\n     * The type of service provided by the plugin, or `null`.\n     */\n    readonly provides: Token<any> | null;\n\n    /**\n     * The function which activates the plugin.\n     */\n    readonly activate: (app: T, ...args: any[]) => any;\n\n    /**\n     * The optional function which deactivates the plugin.\n     */\n    readonly deactivate:\n      | ((app: T, ...args: any[]) => void | Promise<void>)\n      | null;\n\n    /**\n     * Whether the plugin has been activated.\n     */\n    get activated(): boolean {\n      return this._activated;\n    }\n    set activated(a: boolean) {\n      this._activated = a;\n    }\n\n    /**\n     * The resolved service for the plugin, or `null`.\n     */\n    get service(): U | null {\n      return this._service;\n    }\n    set service(s: U | null) {\n      this._service = s;\n    }\n\n    /**\n     * The pending resolver promise, or `null`.\n     */\n    get promise(): Promise<void> | null {\n      return this._promise;\n    }\n    set promise(p: Promise<void> | null) {\n      this._promise = p;\n    }\n  }\n\n  /**\n   * Create a normalized plugin data object for the given plugin.\n   */\n  export function createPluginData<T>(\n    plugin: IPlugin<any, any>\n  ): IPluginData<T> {\n    return new PluginData(plugin);\n  }\n\n  /**\n   * Ensure no cycle is present in the plugin resolution graph.\n   *\n   * If a cycle is detected, an error will be thrown.\n   */\n  export function ensureNoCycle(\n    plugin: IPluginData,\n    plugins: Map<string, IPluginData>,\n    services: Map<Token<any>, string>\n  ): void {\n    const dependencies = [...plugin.requires, ...plugin.optional];\n    const visit = (token: Token<any>): boolean => {\n      if (token === plugin.provides) {\n        return true;\n      }\n      const id = services.get(token);\n      if (!id) {\n        return false;\n      }\n      const visited = plugins.get(id)!;\n      const dependencies = [...visited.requires, ...visited.optional];\n      if (dependencies.length === 0) {\n        return false;\n      }\n      trace.push(id);\n      if (dependencies.some(visit)) {\n        return true;\n      }\n      trace.pop();\n      return false;\n    };\n\n    // Bail early if there cannot be a cycle.\n    if (!plugin.provides || dependencies.length === 0) {\n      return;\n    }\n\n    // Setup a stack to trace service resolution.\n    const trace = [plugin.id];\n\n    // Throw an exception if a cycle is present.\n    if (dependencies.some(visit)) {\n      throw new ReferenceError(`Cycle detected: ${trace.join(' -> ')}.`);\n    }\n  }\n\n  /**\n   * Find dependents in deactivation order.\n   *\n   * @param id - The ID of the plugin of interest.\n   *\n   * @param plugins - The map containing all plugins.\n   *\n   * @param services - The map containing all services.\n   *\n   * @returns A list of dependent plugin IDs in order of deactivation\n   *\n   * #### Notes\n   * The final item of the returned list is always the plugin of interest.\n   */\n  export function findDependents(\n    id: string,\n    plugins: Map<string, IPluginData>,\n    services: Map<Token<any>, string>\n  ): string[] {\n    const edges = new Array<[string, string]>();\n    const add = (id: string): void => {\n      const plugin = plugins.get(id)!;\n      // FIXME In the case of missing optional dependencies, we may consider\n      // deactivating and reactivating the plugin without the missing service.\n      const dependencies = [...plugin.requires, ...plugin.optional];\n      edges.push(\n        ...dependencies.reduce<[string, string][]>((acc, dep) => {\n          const service = services.get(dep);\n          if (service) {\n            // An edge is oriented from dependent to provider.\n            acc.push([id, service]);\n          }\n          return acc;\n        }, [])\n      );\n    };\n\n    for (const id of plugins.keys()) {\n      add(id);\n    }\n\n    // Filter edges\n    // - Get all packages that dependent on the package to be deactivated\n    const newEdges = edges.filter(edge => edge[1] === id);\n    let oldSize = 0;\n    while (newEdges.length > oldSize) {\n      const previousSize = newEdges.length;\n      // Get all packages that dependent on packages that will be deactivated\n      const packagesOfInterest = new Set(newEdges.map(edge => edge[0]));\n      for (const poi of packagesOfInterest) {\n        edges\n          .filter(edge => edge[1] === poi)\n          .forEach(edge => {\n            // We check it is not already included to deal with circular dependencies\n            if (!newEdges.includes(edge)) {\n              newEdges.push(edge);\n            }\n          });\n      }\n      oldSize = previousSize;\n    }\n\n    const sorted = topologicSort(newEdges);\n    const index = sorted.findIndex(candidate => candidate === id);\n\n    if (index === -1) {\n      return [id];\n    }\n\n    return sorted.slice(0, index + 1);\n  }\n\n  /**\n   * Collect the IDs of the plugins to activate on startup.\n   */\n  export function collectStartupPlugins(\n    plugins: Map<string, IPluginData>,\n    options: PluginRegistry.IStartOptions\n  ): string[] {\n    // Create a set to hold the plugin IDs.\n    const collection = new Set<string>();\n\n    // Collect the auto-start (non deferred) plugins.\n    for (const id of plugins.keys()) {\n      if (plugins.get(id)!.autoStart === true) {\n        collection.add(id);\n      }\n    }\n\n    // Add the startup plugins.\n    if (options.startPlugins) {\n      for (const id of options.startPlugins) {\n        collection.add(id);\n      }\n    }\n\n    // Remove the ignored plugins.\n    if (options.ignorePlugins) {\n      for (const id of options.ignorePlugins) {\n        collection.delete(id);\n      }\n    }\n\n    // Return the collected startup plugins.\n    return Array.from(collection);\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n\n// Fallback\nexport function fallbackRandomValues(buffer: Uint8Array): void {\n  let value = 0;\n  for (let i = 0, n = buffer.length; i < n; ++i) {\n    if (i % 4 === 0) {\n      value = (Math.random() * 0xffffffff) >>> 0;\n    }\n    buffer[i] = value & 0xff;\n    value >>>= 8;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n\nimport { fallbackRandomValues } from './random';\n\n// Declare ambient variables for `window` and `require` to avoid a\n// hard dependency on both. This package must run on node.\ndeclare let window: any;\n\n/**\n * The namespace for random number related functionality.\n */\nexport namespace Random {\n  /**\n   * A function which generates random bytes.\n   *\n   * @param buffer - The `Uint8Array` to fill with random bytes.\n   *\n   * #### Notes\n   * A cryptographically strong random number generator will be used if\n   * available. Otherwise, `Math.random` will be used as a fallback for\n   * randomness.\n   *\n   * The following RNGs are supported, listed in order of precedence:\n   *   - `window.crypto.getRandomValues`\n   *   - `window.msCrypto.getRandomValues`\n   *   - `require('crypto').randomFillSync\n   *   - `require('crypto').randomBytes\n   *   - `Math.random`\n   */\n  export const getRandomValues = (() => {\n    // Look up the crypto module if available.\n    const crypto: any =\n      (typeof window !== 'undefined' && (window.crypto || window.msCrypto)) ||\n      null;\n\n    // Modern browsers and IE 11\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n      return function getRandomValues(buffer: Uint8Array): void {\n        return crypto.getRandomValues(buffer);\n      };\n    }\n\n    // Fallback\n    return fallbackRandomValues;\n  })();\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { Random } from './random.browser';\nimport { uuid4Factory } from './uuid';\n\n/**\n * The namespace for UUID related functionality.\n */\nexport namespace UUID {\n  /**\n   * A function which generates UUID v4 identifiers.\n   *\n   * @returns A new UUID v4 string.\n   *\n   * #### Notes\n   * This implementation complies with RFC 4122.\n   *\n   * This uses `Random.getRandomValues()` for random bytes, which in\n   * turn will use the underlying `crypto` module of the platform if\n   * it is available. The fallback for randomness is `Math.random`.\n   */\n  export const uuid4 = uuid4Factory(Random.getRandomValues);\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A function which creates a function that generates UUID v4 identifiers.\n *\n * @returns A new function that creates a UUID v4 string.\n *\n * #### Notes\n * This implementation complies with RFC 4122.\n *\n * This uses `Random.getRandomValues()` for random bytes, which in\n * turn will use the underlying `crypto` module of the platform if\n * it is available. The fallback for randomness is `Math.random`.\n */\nexport function uuid4Factory(\n  getRandomValues: (bytes: Uint8Array) => void\n): () => string {\n  // Create a 16 byte array to hold the random values.\n  const bytes = new Uint8Array(16);\n\n  // Create a look up table from bytes to hex strings.\n  const lut = new Array<string>(256);\n\n  // Pad the single character hex digits with a leading zero.\n  for (let i = 0; i < 16; ++i) {\n    lut[i] = '0' + i.toString(16);\n  }\n\n  // Populate the rest of the hex digits.\n  for (let i = 16; i < 256; ++i) {\n    lut[i] = i.toString(16);\n  }\n\n  // Return a function which generates the UUID.\n  return function uuid4(): string {\n    // Get a new batch of random values.\n    getRandomValues(bytes);\n\n    // Set the UUID version number to 4.\n    bytes[6] = 0x40 | (bytes[6] & 0x0f);\n\n    // Set the clock sequence bit to the RFC spec.\n    bytes[8] = 0x80 | (bytes[8] & 0x3f);\n\n    // Assemble the UUID string.\n    return (\n      lut[bytes[0]] +\n      lut[bytes[1]] +\n      lut[bytes[2]] +\n      lut[bytes[3]] +\n      '-' +\n      lut[bytes[4]] +\n      lut[bytes[5]] +\n      '-' +\n      lut[bytes[6]] +\n      lut[bytes[7]] +\n      '-' +\n      lut[bytes[8]] +\n      lut[bytes[9]] +\n      '-' +\n      lut[bytes[10]] +\n      lut[bytes[11]] +\n      lut[bytes[12]] +\n      lut[bytes[13]] +\n      lut[bytes[14]] +\n      lut[bytes[15]]\n    );\n  };\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n\n/**\n * An object which stores MIME data for general application use.\n *\n * #### Notes\n * This class does not attempt to enforce \"correctness\" of MIME types\n * and their associated data. Since this class is designed to transfer\n * arbitrary data and objects within the same application, it assumes\n * that the user provides correct and accurate data.\n */\nexport class MimeData {\n  /**\n   * Get an array of the MIME types contained within the dataset.\n   *\n   * @returns A new array of the MIME types, in order of insertion.\n   */\n  types(): string[] {\n    return this._types.slice();\n  }\n\n  /**\n   * Test whether the dataset has an entry for the given type.\n   *\n   * @param mime - The MIME type of interest.\n   *\n   * @returns `true` if the dataset contains a value for the given\n   *   MIME type, `false` otherwise.\n   */\n  hasData(mime: string): boolean {\n    return this._types.indexOf(mime) !== -1;\n  }\n\n  /**\n   * Get the data value for the given MIME type.\n   *\n   * @param mime - The MIME type of interest.\n   *\n   * @returns The value for the given MIME type, or `undefined` if\n   *   the dataset does not contain a value for the type.\n   */\n  getData(mime: string): any | undefined {\n    let i = this._types.indexOf(mime);\n    return i !== -1 ? this._values[i] : undefined;\n  }\n\n  /**\n   * Set the data value for the given MIME type.\n   *\n   * @param mime - The MIME type of interest.\n   *\n   * @param data - The data value for the given MIME type.\n   *\n   * #### Notes\n   * This will overwrite any previous entry for the MIME type.\n   */\n  setData(mime: string, data: unknown): void {\n    this.clearData(mime);\n    this._types.push(mime);\n    this._values.push(data);\n  }\n\n  /**\n   * Remove the data entry for the given MIME type.\n   *\n   * @param mime - The MIME type of interest.\n   *\n   * #### Notes\n   * This is a no-op if there is no entry for the given MIME type.\n   */\n  clearData(mime: string): void {\n    let i = this._types.indexOf(mime);\n    if (i !== -1) {\n      this._types.splice(i, 1);\n      this._values.splice(i, 1);\n    }\n  }\n\n  /**\n   * Remove all data entries from the dataset.\n   */\n  clear(): void {\n    this._types.length = 0;\n    this._values.length = 0;\n  }\n\n  private _types: string[] = [];\n  private _values: any[] = [];\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n\n/**\n * A class which wraps a promise into a delegate object.\n *\n * #### Notes\n * This class is useful when the logic to resolve or reject a promise\n * cannot be defined at the point where the promise is created.\n */\nexport class PromiseDelegate<T> {\n  /**\n   * Construct a new promise delegate.\n   */\n  constructor() {\n    this.promise = new Promise<T>((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  /**\n   * The promise wrapped by the delegate.\n   */\n  readonly promise: Promise<T>;\n\n  /**\n   * Resolve the wrapped promise with the given value.\n   *\n   * @param value - The value to use for resolving the promise.\n   */\n  resolve(value: T | PromiseLike<T>): void {\n    let resolve = this._resolve;\n    resolve(value);\n  }\n\n  /**\n   * Reject the wrapped promise with the given value.\n   *\n   * @reason - The reason for rejecting the promise.\n   */\n  reject(reason: unknown): void {\n    let reject = this._reject;\n    reject(reason);\n  }\n\n  private _resolve: (value: T | PromiseLike<T>) => void;\n  private _reject: (reason: any) => void;\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n\n/**\n * A runtime object which captures compile-time type information.\n *\n * #### Notes\n * A token captures the compile-time type of an interface or class in\n * an object which can be used at runtime in a type-safe fashion.\n */\nexport class Token<T> {\n  /**\n   * Construct a new token.\n   *\n   * @param name - A human readable name for the token.\n   * @param description - Token purpose description for documentation.\n   */\n  constructor(name: string, description?: string) {\n    this.name = name;\n    this.description = description ?? '';\n    this._tokenStructuralPropertyT = null!;\n  }\n\n  /**\n   * Token purpose description.\n   */\n  readonly description?: string; // FIXME remove `?` for the next major version\n\n  /**\n   * The human readable name for the token.\n   *\n   * #### Notes\n   * This can be useful for debugging and logging.\n   */\n  readonly name: string;\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  private _tokenStructuralPropertyT: T;\n}\n"],"mappings":"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"}